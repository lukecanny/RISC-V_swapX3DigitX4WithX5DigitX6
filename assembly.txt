# RISC-V assembly program
# swapX3DigitX4WithX5DigitX6
# Anthony Bird, Luke Canny Oct 2022
# 
# Using a range of approaches, which impact 
#   no of instructions
#   no of cycles to execute
#
# Function setup initialises x3, x4, x5, x6 registers
# 
# Register 		Use
#  x3 			 Source for first data
#  x4            Value stored indicates position in x3 for swap.
#  x5            Store the second data
#  x6 			 Value stored indicates position in x5 for swap.
#  x7            counter register


main: 
 jal  x1, setup
 jal x1, mask_one
 jal x1, mask_two
 jal x1, swap
 #                       No instructions          No Cycles
 # jal  x1, srr_mask 	  	3						3
 # jal  x1, srli_mask		5						dependent on x4
 # jal  x1, slli_srli       5                       5
 # jal  x1, slli_mask_srl   8                       dependent on x4
1b: jal x0, 1b    # loop forever 

mask_one:
 addi x7,x0, 0xf	  # Add f to x7 register
 addi x8, x0, 0   # Clear the counter
 beq x8, x4, skip1
 loop1:
  slli x7, x7, 4  # Shift x7 left logically by 4 bits.
  addi x8,x8,1	  # Increment the counter
  bne x8, x4, loop1	# If x8 (the counter) does not equal x4 (the desired position), loop again
 skip1:
 and x7, x7, x3		# x7 AND x3 should copy out the word in position desired from x3 to x7.
 xor x3, x7, x3		# x7 OR x3 will change selected word to 0x0 in x3. 
 jalr x0, 0(x1)	# return

mask_two:
 addi x9,x0, 0xf	  # Add f to x7 register
 addi x10, x0, 0   # Clear the counter
 beq x10, x6, skip2
 loop2:
  slli x9, x9, 4  # Shift x7 left logically by 4 bits.
  addi x10,x10,1	  # Increment the counter
  bne x10, x6, loop2	# If x10 (the counter) does not equal x6 (the desired position), loop again
 skip2:and x9, x9, x5		# x9 AND x5 should copy out the word in position desired from x5 to x9.
 xor x5, x9, x5		# x9 OR x5 will change selected word to 0x0 in x5. 
 jalr x0, 0(x1)	# return
 
swap:
 beq x4, x6, equalSwap # if x4 = x6
 blt x4, x6, lessThanSwap # if x4 < x6
 bge x4, x6, greaterThanSwap
 
equalSwap:	# if x4 = x6
 or x3, x3, x9
 or x5, x5, x7
 jalr x0, 0(x1)	# return
 
lessThanSwap: 
 sub x11, x6, x4
 addi x12, x0, 0   # Clear the counter
 loop3:
  srli x9, x9, 4  # Shift x7 left logically by 4 bits.
  addi x12,x12,1	  # Increment the counter
  bne x12, x6, loop3	# If x10 (the counter) does not equal x6 (the desired position), loop again
 or x3, x3, x9		# Adding value to x3.
 addi x12, x0, 0   # Clear the counter
 loop4:
  slli x7, x7, 4  # Shift x7 left logically by 4 bits.
  addi x12,x12,1	  # Increment the counter
  bne x12, x6, loop4	# If x10 (the counter) does not equal x6 (the desired position), loop again
 or x5,x5,x7
 jalr x0, 0(x1)	# return
 
 
greaterThanSwap: 
 sub x11, x4, x6
 addi x12, x0, 0   # Clear the counter
 loop5:
  slli x9, x9, 4  # Shift x7 left logically by 4 bits.
  addi x12,x12,1	  # Increment the counter
  bne x12, x6, loop5	# If x10 (the counter) does not equal x6 (the desired position), loop again
 or x3, x3, x9		# Adding value to x3.
 addi x12, x0, 0   # Clear the counter
 loop6:
  srli x7, x7, 4  # Shift x7 left logically by 4 bits.
  addi x12,x12,1	  # Increment the counter
  bne x12, x6, loop6	# If x10 (the counter) does not equal x6 (the desired position), loop again
 or x5,x5,x7
 jalr x0, 0(x1)	# return
 
 
 
setup:
 lui x3, 0xb1ade	# x3 = b1ade000
 addi x4, x0, 7		# Selecting position 5 word
 lui x5, 0xb01df
 addi x5, x5, 0xce	# x5 = 0xb01df0ce
 addi x6, x0, 0		# Selecting position 3 word
 
 jalr x0, 0(x1)   # return
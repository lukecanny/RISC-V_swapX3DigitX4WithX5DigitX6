# RISC-V assembly program
# swapX3DigitX4WithX5DigitX6
# Anthony Bird, Luke Canny Oct 2022
# 
# Using a range of approaches, which impact 
#   no of instructions
#   no of cycles to execute
#
# Function setup initialises x3, x4, x5, x6 registers



main:
 jal  x1, setup				# Set up initial registers before program begins
 jal x1, extract_value_one	# Extract nibble from the first value given (stored in x3)
 jal x1, extract_value_two	# Extract nibble from the second value given (stored in x5)
 jal x1, swap				# Swap the two nibbles
# 1b: jal x0, 1b    		# loop forever (program complete)

extract_value_one:
 addi x7,x0, 0xf			# Add f to x7 register
 addi x8, x0, 0   			# Clear the counter
 beq x8, x4, skip1			# If the position selected is zero, skip logical shift loop.
 loop1:						# While loop (while counter != position value)
  slli x7, x7, 4  			# Shift x7 left logically by 4 bits.
  addi x8,x8,1	  			# Increment the counter
  bne x8, x4, loop1			# If x8 (the counter) does not equal x4 (the desired position), loop again
 skip1:						# Skip label
 and x7, x7, x3				# x7 AND x3 copies out the nibble in position desired from x3 to x7.
 xor x3, x7, x3				# x7 OR x3 will change selected nibble to 0x0 in x3. 
 jalr x0, 0(x1)				# return

extract_value_two:
 addi x9,x0, 0xf			# Add f to x7 register
 addi x10, x0, 0   			# Clear the counter
 beq x10, x6, skip2			# If the position selected is zero, skip logical shift loop.
 loop2:						# While loop (while counter != position value)
  slli x9, x9, 4  			# Shift x7 left logically by 4 bits.
  addi x10,x10,1			# Increment the counter
  bne x10, x6, loop2		# If x10 (the counter) does not equal x6 (the desired position), loop again
 skip2:						# Skip label
 and x9, x9, x5				# x9 AND x5 should copy out the nibble in position desired from x5 to x9.
 xor x5, x9, x5				# x9 OR x5 will change selected nibble to 0x0 in x5. 
 jalr x0, 0(x1)				# return
 
swap:
 beq x4, x6, equalSwap 		# if x4 = x6
 blt x4, x6, lessThanSwap 	# if x4 < x6
 bge x4, x6, greaterThanSwap# if x4 > x6
 
equalSwap:					# if x4 = x6
 or x3, x3, x9				# OR will insert nibble from x9 into x3. (x3 has a 0x0 in the destination)
 or x5, x5, x7				# OR will insert nibble from x7 into x5. (x5 has a 0x0 in the destination)
 jalr x0, 0(x1)				# return
 
lessThanSwap: 
 sub x11, x6, x4			# Subtract to get difference between two positions.
 addi x12, x0, 0   			# Clear the counter
 loop3:						# Loop label
  srli x9, x9, 4  			# Shift x7 left logically by 4 bits.
  addi x12,x12,1	  		# Increment the counter
  bne x12, x11, loop3		# If x12 (the counter) does not equal x11 (the result of subtraction), loop again
 or x3, x3, x9				# Inserting nibble into x3.
 
 addi x12, x0, 0   			# Clear the counter
 loop4:						# Loop label
  slli x7, x7, 4  			# Shift x7 left logically by 4 bits.
  addi x12,x12,1	  		# Increment the counter
  bne x12, x11 loop4		# If x12 (the counter) does not equal x11 (the result of subtraction), loop again
 or x5,x5,x7				# Inserting nibble into x5.
 jalr x0, 0(x1)				# return
 
greaterThanSwap: 
 sub x11, x4, x6			# Subtract to get difference between two positions.
 addi x12, x0, 0   			# Clear the counter
 loop5:						# Loop label
  slli x9, x9, 4  			# Shift x7 left logically by 4 bits.
  addi x12,x12,1	  		# Increment the counter
  bne x12, x11, loop5		# If x10 (the counter) does not equal x6 (the desired position), loop again
 or x3, x3, x9				# Inserting nibble into x3.
 
 addi x12, x0, 0   			# Clear the counter
 loop6:						# Loop label
  srli x7, x7, 4  			# Shift x7 left logically by 4 bits.
  addi x12,x12,1	  		# Increment the counter
  bne x12, x11, loop6		# If x10 (the counter) does not equal x6 (the desired position), loop again
 or x5,x5,x7				# Inserting nibble into x5.
 jalr x0, 0(x1)				# return
 
 
setup:
 lui x3, 0xb1ade			# x3 = b1ade000
 addi x4, x0, 7				# Selecting position 5 nibble
 lui x5, 0xb01df
 addi x5, x5, 0xce			# x5 = 0xb01df0ce
 addi x6, x0, 0				# Selecting position 3 nibble
 
 jalr x0, 0(x1)   # return